package votingSystem.encrpytion;


import votingSystem.voter.*;
import votingSystem.encrpytion.*;

import java.math.BigInteger;
import java.security.SecureRandom;
import java.util.*;

public class ObliviousTransfer {

	
    private BigInteger[] availableKeys;
    private byte[] takenKeys;
    private static SecureRandom random;
    
    public ObliviousTransfer(int numKeys){
    	
    	//initialize instance variables. 
		random = new SecureRandom();
		availableKeys = new BigInteger[numKeys];//<BigInteger>();
		takenKeys = new byte[numKeys];//<BigInteger>();
    	
		//generate random keys
    	for(int i = 0; i < numKeys; i++){
   		 	
   		 	//Generate 128-bit voting keys and set the all as available...
   		 	BigInteger p = new BigInteger(128, 100, random);
   		 	
   		 	availableKeys[i] = p;
   		 	takenKeys[i] = 0;
   		 	//Alternatively, we might want to use RSA keys here here
    	}
    }

    
    public BigInteger[] randomMessages(){
    	
    	//the number of keys left available
    	int size = availableKeys.length;

    	
    	//a list of random messages cooresponding to private keys
    	BigInteger[] toRet = new BigInteger[size];
    	
    	//create 128-bit random messages
    	for(int i = 0; i < size; i++){
    		toRet[i] = new BigInteger(128, 100, random);
    	}
    
    	return toRet;
    }
    
    
    /**
     * Secretly chooses a random message out of a list
     * @param randomMessages - a list of random messages to choose from
     * @return the index of the random message
     */
    public static int chooseSecret(BigInteger[] randomMessages){
    	
    	//randomly choose one of the random messages
    	int size = randomMessages.length;
    	int b = random.nextInt(size);
    	
    	return b;
    }
    
    /**
     * generate K - generates a random value (used client side)
     * @return
     */
    public static BigInteger generateK(){
    	return new BigInteger(128, random);
    }
    
    /**
     * Calculates the V value for oblivious transfer (used client side)
     * @param x - the random message produced by the server, chosen by the client
     * @param k - a random value chosen by the client
     * @param e - the e aspect of the public RSA key 
     * @param N - the N aspect of the public RSA key
     * @return the calculated V value
     */
    public static BigInteger calculateV(BigInteger x, BigInteger k, int e, BigInteger n){
    	
    	return (x.add(k.pow(e)).mod(n));//randomMessages[b].add(k.pow(e)))
     }
    
    /**
     * Calculates the K values for all of the random messages
     * @param randomMessages - the list of random messages initially generated
     * @param v - the V value generated by client
     * @param d - the d aspect of the private RSA KEY
     * @param n - the N aspect of the public RSA key
     * @return - the encrypted k values of the random mesages
     */
    public BigInteger[] calculateMs(BigInteger[] randomMessages, BigInteger v, BigInteger d, BigInteger n){
    	
    	BigInteger[] toRet = new BigInteger[randomMessages.length];
    	
    	for(int i = 0; i < randomMessages.length; i++){
    		toRet[i] = availableKeys[i].add((v.subtract(randomMessages[i])).modPow(d, n));
    	}
    	
    	return toRet;
    	
    }
    
    /**
     * Determines the desired message from a list of encrypted k values
     * @param kValues - the list of k-values
     * @param index - the index of the message (chosen earlier)
     * @param k - the random K value (chosen earlier)
     * @return the decrypted message
     */
    public static BigInteger determineMessage(BigInteger[] mValues, int index, BigInteger k){
    	return (mValues[index]).subtract(k);
    }
    
    /**
     * checkSecret - checks the validity of a secret
     * @param toCheck - the integer to check
     * @return true or false based on the key's validity
     */
    public boolean checkSecret(BigInteger toCheck){	
    	
    	//TODO IMPLEMENT THISISISIS
    	return false;//return takenKeys.contains(toCheck);
    }
    
    public BigInteger getSecret(int index){
    	return availableKeys[index];
    }
    
    public static void main(String[] args){
    	
    	ObliviousTransfer test = new ObliviousTransfer(10);
    	RSAEncryption rsa = new RSAEncryption(128);
    	
    	
    	//server side starting
    	BigInteger[] randomMessages = test.randomMessages();
    
    	//client side action
    	int b = test.chooseSecret(randomMessages);
    	System.out.println("b: " + b);
    	
    	BigInteger k = test.generateK();

    	int e = Integer.parseInt(rsa.getE().toString());
    	BigInteger v = test.calculateV(randomMessages[b], k, e, rsa.getN());
    	
    	//server side action
    	BigInteger[] ms = test.calculateMs(randomMessages, v, rsa.getD(), rsa.getN());
    	
    	//client side action
    	BigInteger message = test.determineMessage(ms, b, k);
    	
    	System.out.println("Start: " + test.getSecret(b));
    	System.out.println("End: " + message);
    
    }

}
